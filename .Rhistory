cran_packages <- c("data.table", "plyr", "dplyr", "stringr", "stringi", "seqinr", "parallel", "tidyr", "readxl")
bioc_packages <- c("Biostrings", "GenomicFeatures")
install_if_missing <- function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
install.packages(pkg, dependencies = TRUE)
}
}
# Install all CRAN packages
invisible(sapply(cran_packages, install_if_missing))
# Install BiocManager from CRAN first (if not already installed)
if (!require("BiocManager", quietly = TRUE)) {
install.packages("BiocManager")
}
# Install all Bioconductor packages
invisible(sapply(bioc_packages, function(pkg) {
if (!requireNamespace(pkg, quietly = TRUE)) {
BiocManager::install(pkg, dependencies = TRUE)
}
}))
install.pacman
install.packages("pacman")
install.packages("pacman")
install.packages("pacman")
pkgbuild::find_rtools()
load("C:/Users/Marco/Downloads/snoMatcher/snoMatcher/snoDB_analysis_validated/c_d_dist_pois_scores.RData")
View(c_d_dist_fit)
install.packages("pacman")
pkgbuild::find_rtools()
snodb <- read_xlsx("snoDB_data.xlsx")
library(Biostrings)
library(GenomicRanges)
library(BSgenome)
library(seqinr)
library(dplyr)
library(ggplot2)
library(reshape2)
library(corrplot)
load(file = "results/intermediate/processed_info_box.RData")
master_list <- (c(length_seq, length_c, length_c_prime, length_d, length_d_prime,pos_c, pos_c_prime, pos_d, pos_d_prime, dist_cd, dist_cpd, dist_cpdp, dist_dpc, guide1_start, guide2_start, guide1_length, guide2_length))
final_df <- as.data.frame(do.call(cbind, master_list))
load(file = "results/intermediate/processed_info_box.RData")
replace_minus_one_with_na <- function(df) {
df[df == -1] <- NA
df[df == 0] <- NA
return(df)
}
load(file = "../results/intermediate/processed_info_box.RData")
setwd("C:/Users/Marco/RProject/snoMatcher/")
load(file = "results/intermediate/processed_info_box.RData")
replace_minus_one_with_na <- function(df) {
df[df == -1] <- NA
df[df == 0] <- NA
return(df)
}
pos_seq <- DNAStringSet(snodb_boxes[["DNA Sequence"]])
pos_seq
# looking for correlation between various length
length_seq <- as.data.frame(sapply(snodb_boxes["DNA Sequence"], nchar))
length_c <- as.data.frame(sapply(snodb_boxes["c_seq"], nchar))
length_c_prime <- as.data.frame(sapply(snodb_boxes["c_prime_seq"], nchar))
length_d <- as.data.frame(sapply(snodb_boxes["d_seq"], nchar))
length_d_prime <- as.data.frame(sapply(snodb_boxes["d_prime_seq"], nchar))
pos_c <- as.data.frame(snodb_boxes["c_start"])
pos_c_prime <- as.data.frame(snodb_boxes["c_prime_start"])
pos_d <- as.data.frame(snodb_boxes["d_start"])
pos_d_prime <- as.data.frame(snodb_boxes["d_prime_start"])
dist_cpd <- as.data.frame(snodb_boxes["dist_c_prime_d"])
dist_cd <- as.data.frame(snodb_boxes["dist_c_d"])
dist_dpc <- as.data.frame(snodb_boxes["dist_c_d_prime"])
dist_cpdp <- as.data.frame(snodb_boxes["dist_d_prime_c_prime"])
guide1_length <- as.data.frame(sapply(snodb_boxes["guide1_seq"], nchar))
guide2_length <- as.data.frame(sapply(snodb_boxes["guide2_seq"], nchar))
guide1_start <- as.data.frame(snodb_boxes["guide1_start"])
guide2_start <- as.data.frame(snodb_boxes["guide2_start"])
master_list <- (c(length_seq, length_c, length_c_prime, length_d, length_d_prime,pos_c, pos_c_prime, pos_d, pos_d_prime, dist_cd, dist_cpd, dist_cpdp, dist_dpc, guide1_start, guide2_start, guide1_length, guide2_length))
final_df <- as.data.frame(do.call(cbind, master_list))
cleaned_df <- replace_minus_one_with_na(final_df)
# If you have non-numeric columns, select only numeric ones first
numeric_df <- cleaned_df[, sapply(cleaned_df, is.numeric)]
cor_matrix <- cor(numeric_df, use = "complete.obs")
print(cor_matrix)
# Melt the correlation matrix
melted_cor <- melt(cor_matrix)
# Create heatmap
ggplot(melted_cor, aes(Var1, Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = round(value, 2)), size = 3) +
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
labs(title = "Correlation Matrix", x = "", y = "")
pos_seq <- DNAStringSet(snodb_boxes[["DNA Sequence"]])
pos_seq
generate_random_sequences <- function(positive_seqs, n_random = 1000,
output_file = "random_negatives.fasta") {
cat("Generating random sequences matching positive set properties...\n")
positive_seqs <- snodb_boxes
# Analyze positive sequences
seq_lengths <- sapply(positive_seqs["DNA Sequence"], nchar)
gc_contents <- letterFrequency(DNAStringSet(positive_seqs[["DNA Sequence"]]), letters = "GC", as.prob = TRUE)
# Get distributions
length_mean <- mean(seq_lengths)
length_sd <- sd(seq_lengths)
gc_mean <- mean(gc_contents)
gc_sd <- sd(gc_contents)
# random_seqs <- DNAStringSet()
new_sequences_list <- list()
new_sequences_name <- character(50)
for (i in 1:n_random) {
# Sample length from normal distribution
target_length <- round(rnorm(1, mean = length_mean, sd = length_sd))
target_length <- max(50, min(500, target_length))  # Constrain to reasonable range
# Sample GC content
target_gc <- rnorm(1, mean = gc_mean, sd = gc_sd)
target_gc <- max(0.2, min(0.8, target_gc))  # Constrain between 20-80%
# Generate sequence with target GC content
n_gc <- round(target_length * target_gc)
n_at <- target_length - n_gc
bases <- sample(c(rep("G", floor(n_gc/2)),
rep("C", ceiling(n_gc/2)),
rep("A", floor(n_at/2)),
rep("T", ceiling(n_at/2))))
# seq <- DNAString(paste(bases, collapse = ""))
# names(seq) <- sprintf("random_neg_%04d|len=%d|gc=%.2f", i, target_length, target_gc)
# random_seqs <- c(random_seqs, seq)
seq <- DNAString(paste(bases, collapse = ""))
new_sequences_name[i] <- sprintf("random_neg_%04d|len=%d|gc=%.2f", i, target_length, target_gc)
new_sequences_list[[i]] <- seq
}
random_seqs <- DNAStringSet(new_sequences_list)
names(random_seqs) <- new_sequences_name
# Write to file
# writeXStringSet(random_seqs, filepath = output_file)
cat(sprintf("Generated %d random sequences -> %s\n", n_random, output_file))
return(random_seqs)
}
negatives <- generate_random_sequences(snodb_boxes, 500, "data/generated.fasta")
negatives
library(seqinr)
library(parallel)
library(ggseqlogo)
library(ggplot2)
library(ggbeeswarm)
library(ggpubr)
# library(seqLogo)
library(ape)
library(tidyr)
library(patchwork)
library(tidyverse)
# Check if running with Snakemake or in RStudio
# Need to clear the environment first -> TODO(FIX)
rm(snakemake, envir = .GlobalEnv)
if (!exists("snakemake")) {
# need to change the static hardcoded setwd
setwd("C:/Users/Marco/RProject/snoMatcher/")
# Create mock snakemake object for testing in Rstudio
snakemake <- list(
input = list(
info_box = "results/intermediate/processed_info_box.RData",
guide = "results/intermediate/guide.RData",
negatives = "data/raw/gene_bodies_ENSG00000079974.19_site_6437_.csv",
scores = "results/intermediate/scores.RData"
),
output = list(
snorna_machine_learning = "results/intermediate/snorna_machine_learning.RData"
),
config = list(
generate_plots = TRUE,
export_tables = TRUE
)
)
# Helper function for mock object
get_input <- function(name) snakemake$input[[name]]
get_output <- function(name) snakemake$output[[name]]
get_config <- function(name) snakemake$config[[name]]
# get_threads <- function() snakemake$threads
("Debug execution")
} else {
# somewhat a graphic analysis of the negatives?
# Helper functions for real snakemake object
get_input <- function(name) snakemake@input[[name]]
get_output <- function(name) snakemake@output[[name]]
get_config <- function(name) snakemake@config[[name]]
# get_threads <- function() snakemake@threads
("snakemake execution")
}
load(file = get_input("info_box"))
load(file = get_input("scores"))
load(file = get_input("guide"))
negatives <- read.csv(get_input("negatives"))
View(negatives)
View(negatives)
# what is seq score?? rRNA su negatives e' sempre lo stesso???
negatives <- negatives %>% dplyr::select(unique_id, seq_score, c_box_seq, d_prime_box_seq, c_prime_box_seq, d_box_seq,c_d_prime_dist, d_prime_c_prime_dist, c_prime_d_dist, c_d_dist,)
train_data <- data.frame(
length = sapply(negatives, length),
posc = c(10, 15, 20, 25, 30, 35, 40, 45, 50),
poscp = c(30, 45, 60, 75, 90, 105, 120, 135, 150),
posd = c(60, 90, 120, 150, 180, 210, 240, 270, 300),
posdp = c(90, 135, 180, 225, 270, 315, 360, 405, 450)
)
# Sample training data (replace with your actual data)
set.seed(123)
train_data <- data.frame(
length = sapply(snodb_boxes["DNA Sequence"], nchar),
# posc = c(10, 15, 20, 25, 30, 35, 40, 45, 50),
# poscp = c(30, 45, 60, 75, 90, 105, 120, 135, 150),
# posd = c(60, 90, 120, 150, 180, 210, 240, 270, 300),
# posdp = c(90, 135, 180, 225, 270, 315, 360, 405, 450)
)
train_data <- data.frame(
length = sapply(snodb_boxes["DNA Sequence"], nchar)
# posc = c(10, 15, 20, 25, 30, 35, 40, 45, 50),
# poscp = c(30, 45, 60, 75, 90, 105, 120, 135, 150),
# posd = c(60, 90, 120, 150, 180, 210, 240, 270, 300),
# posdp = c(90, 135, 180, 225, 270, 315, 360, 405, 450)
)
train_data <- data.frame(
length = sapply(snodb_boxes["DNA Sequence"], nchar)
# posc = c(10, 15, 20, 25, 30, 35, 40, 45, 50),
# poscp = c(30, 45, 60, 75, 90, 105, 120, 135, 150),
# posd = c(60, 90, 120, 150, 180, 210, 240, 270, 300),
# posdp = c(90, 135, 180, 225, 270, 315, 360, 405, 450)
)
View(train_data)
# define c,d,c',d' positions using SVM
multipleCorrelation_to_one <- matrix.model( ~ length_seq + d_start ,numeric_df )
# define c,d,c',d' positions using SVM
library(car)
library(corrplot)
multipleCorrelation_to_one <- matrix.model( ~ length_seq + d_start ,numeric_df )
multipleCorrelation_to_one <- model.matrix( ~ length_seq + d_start ,numeric_df )
multipleCorrelation_to_one <- model.matrix( ~ as.data.frame(length_seq) + d_start ,numeric_df )
multipleCorrelation_to_one <- model.matrix( ~ data.frame(length_seq) + d_start ,numeric_df )
typeof(length_c)
# looking for correlation between various length
# length_seq <- as.data.frame(sapply(snodb_boxes["DNA Sequence"], nchar))
library(dplyr)
length_seq <- snodb_boxes %>%
mutate(length = nchar(`DNA Sequence`)) %>%
select(length)
length_c <- as.data.frame(sapply(snodb_boxes["c_seq"], nchar))
length_c_prime <- as.data.frame(sapply(snodb_boxes["c_prime_seq"], nchar))
length_d <- as.data.frame(sapply(snodb_boxes["d_seq"], nchar))
length_d_prime <- as.data.frame(sapply(snodb_boxes["d_prime_seq"], nchar))
pos_c <- as.data.frame(snodb_boxes["c_start"])
pos_c_prime <- as.data.frame(snodb_boxes["c_prime_start"])
pos_d <- as.data.frame(snodb_boxes["d_start"])
pos_d_prime <- as.data.frame(snodb_boxes["d_prime_start"])
dist_cpd <- as.data.frame(snodb_boxes["dist_c_prime_d"])
dist_cd <- as.data.frame(snodb_boxes["dist_c_d"])
dist_dpc <- as.data.frame(snodb_boxes["dist_c_d_prime"])
dist_cpdp <- as.data.frame(snodb_boxes["dist_d_prime_c_prime"])
guide1_length <- as.data.frame(sapply(snodb_boxes["guide1_seq"], nchar))
guide2_length <- as.data.frame(sapply(snodb_boxes["guide2_seq"], nchar))
guide1_start <- as.data.frame(snodb_boxes["guide1_start"])
guide2_start <- as.data.frame(snodb_boxes["guide2_start"])
master_list <- (c(length_seq, length_c, length_c_prime, length_d, length_d_prime,pos_c, pos_c_prime, pos_d, pos_d_prime, dist_cd, dist_cpd, dist_cpdp, dist_dpc, guide1_start, guide2_start, guide1_length, guide2_length))
final_df <- as.data.frame(do.call(cbind, master_list))
cleaned_df <- replace_minus_one_with_na(final_df)
# If you have non-numeric columns, select only numeric ones first
numeric_df <- cleaned_df[, sapply(cleaned_df, is.numeric)]
cor_matrix <- cor(numeric_df, use = "complete.obs")
print(cor_matrix)
# Melt the correlation matrix
melted_cor <- melt(cor_matrix)
# Create heatmap
ggplot(melted_cor, aes(Var1, Var2, fill = value)) +
geom_tile() +
geom_text(aes(label = round(value, 2)), size = 3) +
scale_fill_gradient2(low = "blue", high = "red", mid = "white",
midpoint = 0, limit = c(-1,1)) +
theme_minimal() +
labs(title = "Correlation Matrix", x = "", y = "")
multipleCorrelation_to_one <- model.matrix( ~ length_seq + d_start ,numeric_df )
typeof(length_seq)
length_seq <- snodb_boxes %>%
mutate(length = nchar(`DNA Sequence`)) %>%
select(length)
typeof(length_seq)
length_seq = data.frame(length_seq)
typeof(length_seq)
typeof(c(10, 15, 20, 25, 30, 35, 40, 45, 50))
library(e1071)
library(caret)
# Sample training data (replace with your actual data)
set.seed(123)
train_data <- data.frame(
length = length_seq,
pos1 = length_c,
pos2 = length_c_prime,
pos3 = length_d,
pos4 = length_d_prime
)
# Display training data
print("Training Data:")
print(train_data)
# Sample training data (replace with your actual data)
set.seed(123)
train_data <- data.frame(
length = length_seq,
pos1 = pos_c,
pos2 = pos_c_prime,
pos3 = pos_d,
pos4 = pos_d_prime
)
# Display training data
print("Training Data:")
print(train_data)
# Method 1: SVM with RBF kernel (default - good for non-linear relationships)
cat("\n=== Training SVM models (RBF kernel) for each position ===\n")
# Train individual SVM models
svm_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "radial")
svm_pos2 <- svm(pos2 ~ length, data = train_data, kernel = "radial")
# Train individual SVM models
svm_pos1 <- svm(pos_c ~ length_seq, data = train_data, kernel = "radial")
View(length_c)
View(length_c)
typeof(as.data.frame(do.call(cbind, length_seq)))
typeof(as.data.frame(do.call(rbind, length_seq)))
typeof(unlist(do.call(rbind, length_seq)))
typeof(unlist(length_seq))
(unlist(length_seq))
data.frame(unlist(length_seq))
train_data <- data.frame(
length = data.frame(unlist(length_seq)),
pos1 = data.frame(unlist(pos_c)),
pos2 = data.frame(unlist(pos_c_prime)),
pos3 = data.frame(unlist(pos_d)),
pos4 = data.frame(unlist(pos_d_prime))
)
# Display training data
print("Training Data:")
print(train_data)
# Method 1: SVM with RBF kernel (default - good for non-linear relationships)
cat("\n=== Training SVM models (RBF kernel) for each position ===\n")
# Train individual SVM models
svm_pos1 <- svm(pos_c ~ length_seq, data = train_data, kernel = "radial")
# Train individual SVM models
svm_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "radial")
length = data.frame(unlist(length_seq))
pos1 = data.frame(unlist(pos_c))
# Train individual SVM models
svm_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "radial")
typeod(length)
typeof(length)
# Sample training data (replace with your actual data)
set.seed(123)
train_data <- data.frame(
length = (unlist(length_seq)),
pos1 = (unlist(pos_c)),
pos2 = (unlist(pos_c_prime)),
pos3 = (unlist(pos_d)),
pos4 = (unlist(pos_d_prime))
)
typeof(length)
train_data <- data.frame(
length = unlist(length_seq),
pos1 = unlist(pos_c),
pos2 = unlist(pos_c_prime),
pos3 = unlist(pos_d),
pos4 = unlist(pos_d_prime)
)
# Display training data
print("Training Data:")
print(train_data)
typeof(length)
typeof(numeric_df)
typeof(final_df)
# Train individual SVM models
svm_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "radial")
svm_pos2 <- svm(pos2 ~ length, data = train_data, kernel = "radial")
svm_pos3 <- svm(pos3 ~ length, data = train_data, kernel = "radial")
svm_pos4 <- svm(pos4 ~ length, data = train_data, kernel = "radial")
# Function to predict all positions
predict_positions_svm <- function(length_value) {
new_data <- data.frame(length = length_value)
predictions <- data.frame(
length = length_value,
pos1 = predict(svm_pos1, new_data),
pos2 = predict(svm_pos2, new_data),
pos3 = predict(svm_pos3, new_data),
pos4 = predict(svm_pos4, new_data)
)
return(predictions)
}
# Test predictions
cat("\n=== Testing Predictions (RBF kernel) ===\n")
View(snodb_boxes)
test_lengths <- c(90, 120, 76)
for (len in test_lengths) {
result <- predict_positions_svm(len)
cat(sprintf("\nLength: %.0f -> pos1: %.2f, pos2: %.2f, pos3: %.2f, pos4: %.2f\n",
result$length, result$pos1, result$pos2, result$pos3, result$pos4))
}
# Method 2: SVM with linear kernel (simpler, for linear relationships)
cat("\n\n=== Alternative: SVM with Linear Kernel ===\n")
svm_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "linear")
svm_pos2 <- svm(pos2 ~ length, data = train_data, kernel = "linear")
svm_pos3 <- svm(pos3 ~ length, data = train_data, kernel = "linear")
svm_pos4 <- svm(pos4 ~ length, data = train_data, kernel = "linear")
predict_positions_svm_linear <- function(length_value) {
new_data <- data.frame(length = length_value)
predictions <- data.frame(
length = length_value,
pos1 = predict(svm_lin_pos1, new_data),
pos2 = predict(svm_lin_pos2, new_data),
pos3 = predict(svm_lin_pos3, new_data),
pos4 = predict(svm_lin_pos4, new_data)
)
return(predictions)
}
# Test linear kernel
cat("\n=== Testing Predictions (Linear kernel) ===\n")
for (len in test_lengths) {
result <- predict_positions_svm_linear(len)
cat(sprintf("\nLength: %.0f -> pos1: %.2f, pos2: %.2f, pos3: %.2f, pos4: %.2f\n",
result$length, result$pos1, result$pos2, result$pos3, result$pos4))
}
svm_lin_pos1 <- svm(pos1 ~ length, data = train_data, kernel = "linear")
svm_lin_pos2 <- svm(pos2 ~ length, data = train_data, kernel = "linear")
svm_lin_pos3 <- svm(pos3 ~ length, data = train_data, kernel = "linear")
svm_lin_pos4 <- svm(pos4 ~ length, data = train_data, kernel = "linear")
predict_positions_svm_linear <- function(length_value) {
new_data <- data.frame(length = length_value)
predictions <- data.frame(
length = length_value,
pos1 = predict(svm_lin_pos1, new_data),
pos2 = predict(svm_lin_pos2, new_data),
pos3 = predict(svm_lin_pos3, new_data),
pos4 = predict(svm_lin_pos4, new_data)
)
return(predictions)
}
# Test linear kernel
cat("\n=== Testing Predictions (Linear kernel) ===\n")
for (len in test_lengths) {
result <- predict_positions_svm_linear(len)
cat(sprintf("\nLength: %.0f -> pos1: %.2f, pos2: %.2f, pos3: %.2f, pos4: %.2f\n",
result$length, result$pos1, result$pos2, result$pos3, result$pos4))
}
negatives
negatives <- generate_random_sequences(snodb_boxes, 500, "data/generated.fasta")
negatives
unlist(negatives)
View(negatives)
View(snodb_boxes)
